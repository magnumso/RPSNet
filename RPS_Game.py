{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Load necessary libraries"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import torch\n",
    "import cv2\n",
    "from torchvision import transforms\n",
    "from time import time\n",
    "from random import choice\n",
    "from model_architecture import RPSNet"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Load model\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define the model architecture again (must match the saved model's architecture)\n",
    "model = RPSNet(num_classes=4);\n",
    "\n",
    "# Load the saved model state dictionary\n",
    "model.load_state_dict(torch.load(\"trained_model_5.pth\"))\n",
    "\n",
    "# Move the model to GPU if available\n",
    "device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n",
    "\n",
    "model.to(device);\n",
    "\n",
    "# Set the model to evaluation mode\n",
    "model.eval();"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Test if cuda is available"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "torch.cuda.is_available()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Start game\n",
    "make sure to change the video capture device to the one you want to be using.  \n",
    "Press \"q\" to stop the game"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class ObjectDetection:\n",
    "    def __init__(self, capture_index):\n",
    "        # Sets the device to cuda of its available, else cpu and then displays the device being used\n",
    "        self.capture_index = capture_index\n",
    "        self.device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n",
    "        print(\"Using Device: \", self.device)\n",
    "        \n",
    "        self.model = self.load_model()\n",
    "        self.CLASS_NAMES_DICT = ['Paper', 'Rock', 'Scissor', 'None']\n",
    "        self.user_choice = None\n",
    "        self.current_prediction = None\n",
    "        self.computer_choice = None\n",
    "        self.user_score = 0\n",
    "        self.computer_score = 0\n",
    "        self.draw_score = 0\n",
    "        self.last_prediction_time = None\n",
    "        self.prediction_duration = 3  # How long until the handsign is used to play agains the model\n",
    "        self.choices = ['Rock', 'Paper', 'Scissor']\n",
    "        self.computer_images = {\n",
    "            'Rock': cv2.imread('robot choice/rock.jpg'),\n",
    "            'Paper': cv2.imread('robot choice/paper.jpg'),\n",
    "            'Scissor': cv2.imread('robot choice/scissor.jpg')\n",
    "        }\n",
    "        self.computer_choice_time = None\n",
    "        self.display_duration = 3  # how many seconds to display computer choice before its removed\n",
    "\n",
    "\n",
    "    # Loads our trained model and sets it to evaluation mode so we can make predictions\n",
    "    def load_model(self):\n",
    "        model = RPSNet(num_classes=4)\n",
    "        model.load_state_dict(torch.load(\"trained_model_5.pth\"))\n",
    "        model.to(self.device)\n",
    "        model.eval()\n",
    "        return model\n",
    "    \n",
    "    # Converts the collected frame to a tensor, normalize the values to be\n",
    "    # between 0-1 and then get the prediction from the model\n",
    "    def predict(self, frame):\n",
    "        transform = transforms.Compose([\n",
    "            transforms.ToTensor(),  \n",
    "        ])\n",
    "        frame = transform(frame).unsqueeze(0).to(self.device)\n",
    "        with torch.no_grad():\n",
    "            result = self.model(frame)\n",
    "        return result\n",
    "    \n",
    "    # If the user changes hand sign, the model predicts a different hand sign or none\n",
    "    # then restart the delay of the model prediction\n",
    "    def update_choice(self, prediction):\n",
    "        current_time = time()\n",
    "        if self.current_prediction is None or self.current_prediction != prediction:\n",
    "            self.current_prediction = prediction\n",
    "            self.last_prediction_time = current_time\n",
    "        elif current_time - self.last_prediction_time >= self.prediction_duration:\n",
    "            self.user_choice = prediction\n",
    "            self.make_computer_choice()\n",
    "            self.determine_winner()\n",
    "            self.last_prediction_time = current_time\n",
    "            self.current_prediction = None  # Reset current prediction after making a decision\n",
    "\n",
    "    # Collects a radnom choice out of the 3 classes and sets it as the computers choice\n",
    "    def make_computer_choice(self):\n",
    "        self.computer_choice = choice(self.choices)\n",
    "        self.computer_choice_time = time()\n",
    "        \n",
    "    # Compares the choices of the user and the random choice of the computer and displays the winner\n",
    "    # or if its a draw and then adds a point to the score of the winner\n",
    "    def determine_winner(self):\n",
    "        print(f\"Determining winner...\")\n",
    "        print(f\"User choice: {self.user_choice}\")\n",
    "        print(f\"Computer choice: {self.computer_choice}\")\n",
    "        if self.user_choice == self.computer_choice:\n",
    "            winner = 'draw'\n",
    "            self.draw_score += 1\n",
    "            \n",
    "        elif (self.user_choice == 'Rock' and self.computer_choice == 'Scissor') or \\\n",
    "             (self.user_choice == 'Paper' and self.computer_choice == 'Rock') or \\\n",
    "             (self.user_choice == 'Scissor' and self.computer_choice == 'Paper'):\n",
    "            winner = 'user'\n",
    "            self.user_score += 1\n",
    "            \n",
    "        else:\n",
    "            winner = 'computer'\n",
    "            self.computer_score += 1\n",
    "        print(f\"Winner: {winner}\")\n",
    "        \n",
    "    # Displays the computers choice in a orange rectangle on the left in the same size as the users rectangle\n",
    "    # the computers choice is representad as a image which displays which class it is.\n",
    "    def display_computer_choice(self, frame):\n",
    "        comp_x1, comp_y1 = 50, 220\n",
    "        comp_x2, comp_y2 = comp_x1 + 416, comp_y1 + 416\n",
    "\n",
    "        cv2.rectangle(frame, (comp_x1, comp_y1), (comp_x2, comp_y2), (10, 89, 190), 2)\n",
    "\n",
    "        if self.computer_choice and time() - self.computer_choice_time <= self.display_duration:\n",
    "            comp_img = self.computer_images[self.computer_choice]\n",
    "            frame[220:220+comp_img.shape[0], 50:50+comp_img.shape[1]] = comp_img\n",
    "        elif self.computer_choice and time() - self.computer_choice_time > self.display_duration:\n",
    "            self.computer_choice = None\n",
    "\n",
    "    # Opens the video capture device we set it to and displays a 1280 x 720 frame along with the\n",
    "    # game interface.\n",
    "    def __call__(self):\n",
    "        cap = cv2.VideoCapture(self.capture_index)\n",
    "        assert cap.isOpened()\n",
    "        cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)\n",
    "        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)\n",
    "\n",
    "        start_time = time()\n",
    "        frame_count = 0\n",
    "\n",
    "        while True:\n",
    "            ret, frame = cap.read()\n",
    "            assert ret\n",
    "\n",
    "            # Define the rectangle dimentions for the user\n",
    "            x1, y1 = 800, 220\n",
    "            x2, y2 = x1 + 416, y1 + 416\n",
    "            \n",
    "            # Extract the frame from teh user rectangle and pass it to the model\n",
    "            # and get the prediction\n",
    "            cv2.rectangle(frame, (x1, y1), (x2, y2), (202, 119, 43), 2)\n",
    "            roi = frame[y1:y2, x1:x2]\n",
    "            roi = cv2.cvtColor(roi, cv2.COLOR_BGR2RGB)\n",
    "            roi = cv2.resize(roi, (416, 416))\n",
    "\n",
    "            result = self.predict(roi)\n",
    "\n",
    "            # Convert the prediction to one of the string classes and get the confidence score by\n",
    "            # applying softmax to the result.\n",
    "            predicted_label_index = torch.argmax(result, dim=1).cpu().numpy()[0]\n",
    "            predicted_label = self.CLASS_NAMES_DICT[predicted_label_index]\n",
    "            confidence_score = torch.softmax(result, dim=1)[0, predicted_label_index].item()\n",
    "            \n",
    "            # Display the predicted class along with the confidence score if the model predicts a class in the frame\n",
    "            if predicted_label != 'None':\n",
    "                print(f\"Predicted label: {predicted_label} (Confidence: {confidence_score:.2f})\")\n",
    "                cv2.putText(frame, f\"{predicted_label} ({confidence_score:.2f})\", (800, 150), cv2.FONT_HERSHEY_SIMPLEX, 1.5, (202, 119, 43), 2)\n",
    "                self.update_choice(predicted_label)\n",
    "            else:\n",
    "                self.current_prediction = None\n",
    "                self.last_prediction_time = None\n",
    "\n",
    "            self.display_computer_choice(frame)\n",
    "\n",
    "            # Display the scores\n",
    "            cv2.putText(frame, f\"User: {self.user_score}\", (800, 200), cv2.FONT_HERSHEY_SIMPLEX, 1.5, (202, 119, 43), 2)\n",
    "            cv2.putText(frame, f\"Computer: {self.computer_score}\", (50, 200), cv2.FONT_HERSHEY_SIMPLEX, 1.5, (10, 89, 190), 2)\n",
    "            cv2.putText(frame, f\"Draw: {self.draw_score}\", (550,200), cv2.FONT_HERSHEY_SIMPLEX, 1.5, (81, 22, 161), 2)\n",
    "            \n",
    "            # Display the frames per second\n",
    "            frame_count += 1\n",
    "            elapsed_time = time() - start_time\n",
    "            fps = frame_count / elapsed_time\n",
    "            cv2.putText(frame, f\"FPS: {fps:.2f}\", (20, 70), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 0, 0), 2)\n",
    "            \n",
    "            # Display frame with all the added features\n",
    "            cv2.imshow(\"frame\", frame)\n",
    "            \n",
    "            # Press 'q' to quit\n",
    "            if cv2.waitKey(1) & 0xFF == ord('q'):\n",
    "                break\n",
    "            \n",
    "        # Releases capture device                \n",
    "        cap.release()\n",
    "        cv2.destroyAllWindows()\n",
    "        \n",
    "# Start the game\n",
    "detector = ObjectDetection(capture_index=1)\n",
    "detector()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
